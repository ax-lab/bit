package bit

import (
	"fmt"
	"strings"
	"time"
	"unicode/utf8"
)

type CppContext struct {
	program          *Program
	root             *CppContext
	includeSystem    []string
	includeLocal     []string
	includeSystemMap map[string]bool
	includeLocalMap  map[string]bool

	OutputFilePrefix *CppWriter
	OutputFileSuffix *CppWriter
	OutputFunc       *CppWriter
	OutputExpr       *CppWriter
}

type CppWriter struct {
	Context *CppContext
	Output  strings.Builder

	indent string
}

func NewCppContext(program *Program) *CppContext {
	cpp := &CppContext{
		program: program,
	}
	cpp.root = cpp
	cpp.OutputFilePrefix = &CppWriter{Context: cpp}
	cpp.OutputFileSuffix = &CppWriter{Context: cpp}
	return cpp
}

func (ctx *CppContext) GetOutputFiles(mainFile string) (out map[string]string) {
	header := fmt.Sprintf("// AUTO-GENERATED BY BUILD AT %s\n", time.Now().Format(time.RFC3339))
	main := strings.Builder{}
	main.WriteString(header)

	if len(ctx.includeSystem) > 0 {
		main.WriteString("\n")
		for _, it := range ctx.includeSystem {
			main.WriteString(fmt.Sprintf("#include <%s>\n", it))
		}
	}

	if len(ctx.includeLocal) > 0 {
		main.WriteString("\n")
		for _, it := range ctx.includeSystem {
			main.WriteString(fmt.Sprintf("#include \"%s\"\n", it))
		}
	}

	if txt := ctx.OutputFilePrefix.Text(); len(txt) > 0 {
		main.WriteString("\n")
		main.WriteString(txt)
	}

	if txt := ctx.OutputFileSuffix.Text(); len(txt) > 0 {
		main.WriteString("\n")
		main.WriteString(txt)
	}

	main.WriteString("\n")

	out = make(map[string]string)
	out[mainFile] = main.String()
	return
}

func (ctx *CppContext) InitExpr(parent *CppContext) {
	*ctx = *parent
	ctx.OutputExpr = &CppWriter{Context: parent}
}

func (ctx *CppContext) InitFunc(parent *CppContext) {
	*ctx = *parent
	ctx.OutputFunc = &CppWriter{Context: parent}
	ctx.OutputExpr = &CppWriter{Context: parent}
}

func (ctx *CppContext) WriteFunc(header string, output func(ctx *CppContext)) {
	pre := ctx.OutputFilePrefix
	pre.Sep()
	pre.Write("%s;\n", header)

	fn := CppContext{}
	fn.InitFunc(ctx)
	output(&fn)

	pos := ctx.OutputFileSuffix
	pos.Sep()
	pos.Write("%s {\n", header)
	pos.Indent()
	pos.Write(fn.OutputFunc.Text())
	pos.NewLine()
	pos.Dedent()
	pos.Write("}\n")
}

func (ctx *CppContext) IncludeSystem(file string) {
	root := ctx.root
	if !root.includeSystemMap[file] {
		if root.includeSystemMap == nil {
			root.includeSystemMap = make(map[string]bool)
		}
		root.includeSystemMap[file] = true
		root.includeSystem = append(root.includeSystem, file)
	}
}

func (ctx *CppContext) IncludeLocal(file string) {
	root := ctx.root
	if !root.includeLocalMap[file] {
		if root.includeLocalMap == nil {
			root.includeLocalMap = make(map[string]bool)
		}
		root.includeLocalMap[file] = true
		root.includeLocal = append(root.includeLocal, file)
	}
}

func (cpp *CppWriter) Text() string {
	return cpp.Output.String()
}

func (cpp *CppWriter) Len() int {
	return cpp.Output.Len()
}

func (cpp *CppWriter) Indent() {
	cpp.indent = cpp.indent + "\t"
}

func (cpp *CppWriter) Dedent() {
	cpp.indent = cpp.indent[:len(cpp.indent)-1]
}

func (cpp *CppWriter) IsNewLine() bool {
	str := cpp.Output.String()
	return str == "" || strings.HasSuffix(str, "\n")
}

func (cpp *CppWriter) EndStatement() {
	if cpp.Len() == 0 {
		return
	}

	txt := cpp.Output.String()
	if strings.HasSuffix(txt, ";") {
		cpp.Output.WriteRune('\n')
	} else if !strings.HasSuffix(txt, ";\n") {
		cpp.Output.WriteString(";\n")
	}
}

func (cpp *CppWriter) Sep() {
	if cpp.Len() == 0 {
		return
	}

	txt := cpp.Output.String()
	if !strings.HasSuffix(txt, "\n\n") {
		cpp.NewLine()
		cpp.Output.WriteString("\n")
	}
}

func (cpp *CppWriter) NewLine() {
	if !cpp.IsNewLine() {
		cpp.Output.WriteRune('\n')
	}
}

func (cpp *CppWriter) Write(str string, args ...any) {
	if len(args) > 0 {
		str = fmt.Sprintf(str, args...)
	}
	if len(str) == 0 {
		return
	}

	if len(cpp.indent) > 0 {
		eol := cpp.IsNewLine()
		for n, line := range strings.Split(str, "\n") {
			if n > 0 {
				cpp.Output.WriteRune('\n')
				eol = true
			}
			if len(line) > 0 {
				if eol {
					cpp.Output.WriteString(cpp.indent)
				}
				cpp.Output.WriteString(line)
			}
		}

	} else {
		cpp.Output.WriteString(str)
	}
}

func (cpp *CppWriter) WriteLiteralString(str string) {
	out := &cpp.Output
	out.WriteRune('"')
	for _, chr := range str {
		cppOutputChar(chr, out)
	}
	out.WriteRune('"')
}

func cppOutputChar(chr rune, out *strings.Builder) {
	seq := ""
	switch chr {
	case '?':
		seq = "\\?"
	case '"':
		seq = "\\\""
	case '\'':
		seq = "\\'"
	case '\\':
		seq = "\\\\"
	case '\x00':
		seq = "\\0"
	case '\t':
		seq = "\\t"
	case '\n':
		seq = "\\n"
	case '\r':
		seq = "\\r"
	case '\x08':
		seq = "\\b"
	default:
		if cppIsSafeStrChar(chr) {
			out.WriteRune(chr)
		} else {
			buf := [utf8.UTFMax]byte{}
			len := utf8.EncodeRune(buf[:], chr)
			for _, b := range buf[:len] {
				out.WriteString(fmt.Sprintf("\\x%X", b))
			}
		}
	}
	if seq != "" {
		out.WriteString(seq)
	}
}

func cppIsSafeStrChar(chr rune) bool {
	switch chr {
	case
		'_', ' ', '!', '#', '$', '%', '&', '(', ')', '*', '+', ',', '-', '.', '/',
		':', ';', '<', '=', '>', '@', '[', ']', '^', '`', '{', '|', '}', '~':
		return true
	}

	if 'A' <= chr && chr <= 'Z' {
		return true
	}

	if 'a' <= chr && chr <= 'z' {
		return true
	}

	if '0' <= chr && chr <= '9' {
		return true
	}

	return false
}
