package code

import (
	"fmt"
	"io"
	"strings"
	"sync/atomic"
	"time"
	"unicode/utf8"
)

func NewCppContext() *CppContext {
	ctx := &CppContext{
		File: &CppFile{},
	}
	main := ctx.File.NewFunc("int main(int argc, char *argv[])")
	ctx.Body = &main.Body
	return ctx
}

type CppContext struct {
	File *CppFile
	Body *CppLines

	name atomic.Int64
}

type CppFile struct {
	Context *CppContext
	Header  CppLines
	Footer  CppLines
	Funcs   []*CppFunc

	includeSystem    []string
	includeLocal     []string
	includeSystemMap map[string]bool
	includeLocalMap  map[string]bool
}

type CppFunc struct {
	Context *CppContext
	File    *CppFile
	Header  string
	Body    CppLines
}

func (file *CppFile) NewFunc(header string) *CppFunc {
	fn := &CppFunc{
		Context: file.Context,
		File:    file,
		Header:  header,
	}
	file.Funcs = append(file.Funcs, fn)
	return fn
}

func (ctx *CppContext) NewName(base string) string {
	count := ctx.name.Add(1)
	return fmt.Sprintf("$$tmp_%s_%d", base, count)
}

func (ctx *CppContext) ExprString(expr Expr) string {
	body := ctx.Body

	tmp := CppLines{}
	ctx.Body = &tmp
	expr.OutputCpp(ctx)
	ctx.Body = body

	if len(tmp.lines) != 1 || tmp.lines[0] == "" {
		panic("invalid expression output")
	}
	return tmp.lines[0]
}

func (ctx *CppContext) IncludeSystem(file string) {
	root := ctx.File
	if !root.includeSystemMap[file] {
		if root.includeSystemMap == nil {
			root.includeSystemMap = make(map[string]bool)
		}
		root.includeSystemMap[file] = true
		root.includeSystem = append(root.includeSystem, file)
	}
}

func (ctx *CppContext) IncludeLocal(file string) {
	root := ctx.File
	if !root.includeLocalMap[file] {
		if root.includeLocalMap == nil {
			root.includeLocalMap = make(map[string]bool)
		}
		root.includeLocalMap[file] = true
		root.includeLocal = append(root.includeLocal, file)
	}
}

func (ctx *CppContext) GetOutputFiles(mainFile string) (out map[string]string) {
	out = make(map[string]string)
	out[mainFile] = ctx.File.Text()
	return
}

type CppLines struct {
	indent string
	lines  []string
	text   string
}

func (txt *CppLines) Len() int {
	return len(txt.lines)
}

func (txt *CppLines) Indent() {
	txt.indent += "\t"
}

func (txt *CppLines) Dedent() {
	txt.indent = txt.indent[:len(txt.indent)-1]
}

func (txt *CppLines) NewLine() {
	txt.lines = append(txt.lines, "")
}

func (txt *CppLines) EnsureBlank() {
	if len(txt.lines) > 0 && txt.lines[len(txt.lines)-1] != "" {
		txt.Push("")
	}
}

func (txt *CppLines) AppendTo(other *CppLines) {
	for _, it := range txt.lines {
		other.Push(it)
	}
}

func (txt *CppLines) Push(text string, args ...any) {
	if len(args) > 0 {
		text = fmt.Sprintf(text, args...)
	}
	if len(text) > 0 {
		text = txt.indent + text
	}
	txt.lines = append(txt.lines, text)
	txt.text = ""
}

func (txt *CppLines) WriteString(s string) (n int, err error) {
	txt.Write(s)
	return len(s), nil
}

func (txt *CppLines) WriteFmt(s string, args ...any) {
	txt.Write(fmt.Sprintf(s, args...))
}

func (txt *CppLines) Write(s string) {
	if len(txt.lines) == 0 {
		txt.lines = append(txt.lines, s)
	} else {
		txt.lines[len(txt.lines)-1] += s
	}
}

func (txt *CppLines) Text() string {
	if len(txt.text) == 0 {
		txt.text = strings.Join(txt.lines, "\n")
	}
	return txt.text
}

func (txt *CppLines) OutputTo(out *strings.Builder, level int) {
	indent := strings.Repeat("\t", level)
	for n, it := range txt.lines {
		if n > 0 {
			out.WriteString("\n")
		}
		if it != "" {
			out.WriteString(indent)
		}
		out.WriteString(it)
	}
}

func (file *CppFile) Text() string {
	header := fmt.Sprintf("// AUTO-GENERATED BY BUILD AT %s\n", time.Now().Format(time.RFC3339))
	text := strings.Builder{}
	text.WriteString(header)

	if len(file.includeSystem) > 0 {
		text.WriteString("\n")
		for _, it := range file.includeSystem {
			text.WriteString(fmt.Sprintf("#include <%s>\n", it))
		}
	}

	if len(file.includeLocal) > 0 {
		text.WriteString("\n")
		for _, it := range file.includeSystem {
			text.WriteString(fmt.Sprintf("#include \"%s\"\n", it))
		}
	}

	if txt := file.Header.Text(); len(txt) > 0 {
		text.WriteString("\n")
		text.WriteString(txt)
		text.WriteString("\n")
	}

	for _, it := range file.Funcs {
		text.WriteString("\n")
		text.WriteString(it.Header)
		text.WriteString(";\n")
	}

	for _, it := range file.Funcs {
		text.WriteString("\n")
		it.Output(&text)
		text.WriteString("\n")
	}

	if txt := file.Footer.Text(); len(txt) > 0 {
		text.WriteString("\n")
		text.WriteString(txt)
		text.WriteString("\n")
	}

	return text.String()
}

func (fn *CppFunc) Output(out *strings.Builder) {
	out.WriteString(fn.Header)
	out.WriteString("\n{\n")
	fn.Body.OutputTo(out, 1)
	out.WriteString("\n}")
}

func WriteLiteralString(out io.StringWriter, str string) {
	out.WriteString("\"")
	for _, chr := range str {
		cppOutputChar(chr, out)
	}
	out.WriteString("\"")
}

func cppOutputChar(chr rune, out io.StringWriter) {
	seq := ""
	switch chr {
	case '?':
		seq = "\\?"
	case '"':
		seq = "\\\""
	case '\'':
		seq = "\\'"
	case '\\':
		seq = "\\\\"
	case '\x00':
		seq = "\\0"
	case '\t':
		seq = "\\t"
	case '\n':
		seq = "\\n"
	case '\r':
		seq = "\\r"
	case '\x08':
		seq = "\\b"
	default:
		if cppIsSafeStrChar(chr) {
			out.WriteString(string(chr))
		} else {
			buf := [utf8.UTFMax]byte{}
			len := utf8.EncodeRune(buf[:], chr)
			for _, b := range buf[:len] {
				out.WriteString(fmt.Sprintf("\\x%X", b))
			}
		}
	}
	if seq != "" {
		out.WriteString(seq)
	}
}

func cppIsSafeStrChar(chr rune) bool {
	switch chr {
	case
		'_', ' ', '!', '#', '$', '%', '&', '(', ')', '*', '+', ',', '-', '.', '/',
		':', ';', '<', '=', '>', '@', '[', ']', '^', '`', '{', '|', '}', '~':
		return true
	}

	if 'A' <= chr && chr <= 'Z' {
		return true
	}

	if 'a' <= chr && chr <= 'z' {
		return true
	}

	if '0' <= chr && chr <= '9' {
		return true
	}

	return false
}
